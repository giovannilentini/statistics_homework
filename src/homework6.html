<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Homework 6</title>

  <link rel="stylesheet" href="../include/css/style.css" />
  <link rel="stylesheet" href="../include/css/content.css" />
  <link rel="stylesheet" href="../include/css/code_block.css" />

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/auto-render.min.js"
          crossorigin="anonymous"
          onload="renderMathInElement(document.body,{
            delimiters:[
              {left:'\\(', right:'\\)', display:false},
              {left:'\\[', right:'\\]', display:true}
            ]
          });">
  </script>

  <style>
    .stat-card {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      padding: 1rem 1.25rem;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.75rem;
    }

    @media (max-width: 900px) {
      .stat-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .stat {
      background: #f8f9fa;
      border-radius: 6px;
      padding: 0.75rem;
      text-align: center;
    }

    .stat .label {
      font-size: 0.8rem;
      color: #7f8c8d;
    }

    .stat .value {
      font-weight: 700;
      color: #2c3e50;
      font-size: 1.05rem;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(6, minmax(120px, 1fr));
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }

    @media (max-width: 1100px) {
      .controls {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    @media (max-width: 600px) {
      .controls {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .control {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .control label {
      font-size: 0.9rem;
      color: #34495e;
      font-weight: 600;
    }

    .control input,
    .control select,
    .control textarea {
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      padding: 0.5rem 0.6rem;
      font-size: 0.95rem;
      color: #2c3e50;
      background: #fff;
    }

    .buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .btn {
      padding: 0.55rem 0.9rem;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
    }

    .btn-primary {
      background: #3498db;
      color: #fff;
    }

    .btn-success {
      background: #2ecc71;
      color: #fff;
    }

    .btn-danger {
      background: #e74c3c;
      color: #fff;
    }

    .btn-warning {
      background: #f1c40f;
      color: #2c3e50;
    }

    .chart-box {
      background: #fff;
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .chart-box h4 {
      color: #2c3e50;
      margin: 0 0 0.5rem 0;
      padding-bottom: 0.25rem;
      border-bottom: 2px solid #3498db;
      font-size: 1.05rem;
      font-weight: 700;
    }

    .chart-container {
      position: relative;
      width: 100%;
      height: 360px;
    }

    @media (max-width: 600px) {
      .chart-container {
        height: 300px;
      }
    }

    .hidden {
      display: none !important;
    }

    .nav-links {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    .btn-link {
      display: inline-block;
      padding: 0.55rem 0.9rem;
      border-radius: 6px;
      text-decoration: none;
      font-weight: 600;
    }

    .btn-secondary {
      background: #95a5a6;
      color: #fff;
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>Statistics Homework Blog</h1>
      <p class="subtitle">Recurrences & Online Algorithms — Interactive Lab</p>
      <p class="student-info">Giovanni Lentini - 1987799</p>
    </div>
  </header>

  <main class="container">
    <div class="back-navigation">
      <a href="../index.html" class="btn-back">← Back to Home</a>
    </div>

    <article class="homework-detail">
      <div class="homework-header">
        <h2>Homework 6: Recurrences & Streaming Lab</h2>
        <div class="meta-info"><span class="date">Due: November 5, 2025</span></div>
      </div>

      <section class="homework-content">
        <p class="intro-paragraph">
          This page derives the simplest recurrences for the arithmetic mean and variance and provides numerically stable streaming implementations.
          The interactive lab below demonstrates the Law of Large Numbers and convergence to theoretical parameters.
        </p>

        <h3>Recursive Form of the Mean</h3>
        <p>
          Starting from \( \bar{x}_n=\frac{1}{n}\sum_{i=1}^{n}x_i \), we derive the online update:
          \( \bar{x}_n=\bar{x}_{n-1}+\frac{x_n-\bar{x}_{n-1}}{n} \). This enables \(O(1)\) updates without storing history.
        </p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Math</span>
            <span class="code-title">Mean Recurrence (Derivation)</span>
          </div>
<pre><code>\[
\bar{x}_n
=\frac{(n-1)\bar{x}_{n-1}+x_n}{n}
=\bar{x}_{n-1}+\frac{x_n-\bar{x}_{n-1}}{n}.
\]
</code></pre>
        </div>

        <h3>Recursive Variance (Stable: Welford)</h3>
        <p>
          To compute variance online, we maintain \( M_2=\sum_{i=1}^{n}(x_i-\mu)^2 \) using updates on differences.
          This method, known as Welford's Algorithm, is numerically robust.
        </p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Math</span>
            <span class="code-title">Welford's Algorithm (Online)</span>
          </div>
<pre><code>\[
\delta=x_n-\mu_{n-1},\quad
\mu_n=\mu_{n-1}+\frac{\delta}{n},\quad
\delta_2=x_n-\mu_n,\quad
M_{2,n}=M_{2,n-1}+\delta\,\delta_2,\quad
s_n^2=\frac{M_{2,n}}{n-1}.
\]
</code></pre>
        </div>

        <h3>Numerical Discussion</h3>
        <p>
          Traditional batch algorithms require two passes or maintaining large sums, which can be unstable.
        </p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Math</span>
            <span class="code-title">Standard (Batch) Definition</span>
          </div>
<pre><code>\[
\bar{x}=\frac{1}{n}\sum_{i=1}^{n}x_i,\quad
s^2=\frac{1}{n-1}\sum_{i=1}^{n}(x_i-\bar{x})^2.
\]
</code></pre>
        </div>

        <h4>The Problem: Catastrophic Cancellation</h4>
        <p>
          If we use the naive "sum of squares" formula \( \sum x^2 - (\sum x)^2/n \) on data with a large offset, precision loss occurs.
          For example, consider the sequence \( [10^8+1, 10^8+2, 10^8+3] \).
          The variance should be \(1\). However, standard floating-point arithmetic (IEEE 754) might calculate this as \(0\) because the squared terms are too large to preserve the small differences.
          <strong>Welford's method</strong> handles this correctly by only accumulating differences from the mean.
        </p>

        <h4>Scalability</h4>
        <p>
          Online algorithms allow us to merge statistics from distributed systems. For two sets \(A\) and \(B\), the combined variance uses the "Within-Group + Between-Group" property:
        </p>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Math</span>
            <span class="code-title">Parallel Variance Update</span>
          </div>
<pre><code>\[
M_{2,AB} = M_{2,A} + M_{2,B} +
\frac{n_A n_B}{n_A+n_B}(\mu_A - \mu_B)^2.
\]
</code></pre>
        </div>

        <h3>Interactive Lab: Streaming & Convergence</h3>
        <p>
          Stream data to observe the running mean and variance converge to the theoretical truth (Green Line).
        </p>

        <div class="stat-card">
          <div class="controls">
            <div class="control">
              <label for="srcSelect">Source</label>
              <select id="srcSelect">
                <option value="uniform">Uniform [a, b]</option>
                <option value="normal">Normal (μ, σ)</option>
                <option value="manual">Manual Input</option>
              </select>
            </div>

            <div class="control src-group" id="groupUniform">
              <label for="aInput">a (Uniform)</label>
              <input type="number" id="aInput" value="0" step="0.1" />
            </div>
            <div class="control src-group" id="groupUniformB">
              <label for="bInput">b (Uniform)</label>
              <input type="number" id="bInput" value="1" step="0.1" />
            </div>

            <div class="control src-group hidden" id="groupNormal">
              <label for="muInput">μ (Normal)</label>
              <input type="number" id="muInput" value="0" step="0.1" disabled />
            </div>
            <div class="control src-group hidden" id="groupNormalSigma">
              <label for="sigmaInput">σ (Normal)</label>
              <input type="number" id="sigmaInput" value="1" step="0.1" disabled />
            </div>

            <div class="control">
              <label for="nBatchInput">Batch size</label>
              <input type="number" id="nBatchInput" value="100" min="1" />
            </div>
          </div>

          <div class="control src-group hidden" id="groupManual" style="grid-column: 1/-1; margin-bottom: 0.75rem;">
            <label for="manualInput">Manual input</label>
            <textarea id="manualInput" rows="2" placeholder="e.g. 1, 2, 2.5, 3" disabled></textarea>
            <button class="btn btn-warning" id="btnBigNum" style="font-size:0.85rem; margin-top:0.5rem; width: fit-content;">
              Load Instability Test (Big Numbers)
            </button>
          </div>

          <div class="buttons">
            <button class="btn btn-primary" id="btnStream">Stream batch</button>
            <button class="btn btn-success" id="btnStep">Step one</button>
            <button class="btn btn-danger" id="btnReset">Reset</button>
          </div>

          <div class="stat-grid" style="margin-top:0.75rem">
            <div class="stat"><div class="label">n</div><div class="value" id="statN">0</div></div>
            <div class="stat"><div class="label">Mean</div><div class="value" id="statMean">—</div></div>
            <div class="stat"><div class="label">Variance (sample)</div><div class="value" id="statVar">—</div></div>
            <div class="stat"><div class="label">Std. Dev.</div><div class="value" id="statStd">—</div></div>
          </div>
        </div>

        <div class="visualization-container">
          <h5>Running Mean vs Theoretical Mean</h5>
          <div class="chart-placeholder chart-box">
            <div class="chart-container"><canvas id="meanChart"></canvas></div>
          </div>

          <h5>Running Variance vs Theoretical Variance</h5>
          <div class="chart-placeholder chart-box">
            <div class="chart-container"><canvas id="varChart"></canvas></div>
          </div>
        </div>

      </section>
    </article>
  </main>

  <script>
    function randUniform(a, b) { return a + (b - a) * Math.random(); }
    function randNormal(mu, sigma) {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
      return mu + sigma * z;
    }
    function parseManual(text) {
      return text.split(/[\s,;]+/g)
        .map(s => s.trim()).filter(Boolean)
        .map(Number).filter(Number.isFinite);
    }

    class Welford {
      constructor(){ this.n=0; this.mean=0; this.M2=0; }
      add(x){
        this.n += 1;
        const d = x - this.mean;
        this.mean += d / this.n;
        const d2 = x - this.mean;
        this.M2 += d * d2;
      }
      count(){ return this.n; }
      sampleVariance(){ return this.n > 1 ? this.M2 / (this.n - 1) : NaN; }
      std(){ const v = this.sampleVariance(); return Number.isFinite(v) ? Math.sqrt(v) : NaN; }
      reset(){ this.n=0; this.mean=0; this.M2=0; }
    }

    const srcSelect = document.getElementById('srcSelect');
    const aInput = document.getElementById('aInput');
    const bInput = document.getElementById('bInput');
    const muInput = document.getElementById('muInput');
    const sigmaInput = document.getElementById('sigmaInput');
    const nBatchInput = document.getElementById('nBatchInput');
    const manualInput = document.getElementById('manualInput');
    const btnBigNum = document.getElementById('btnBigNum');

    const groupUniform = document.getElementById('groupUniform');
    const groupUniformB = document.getElementById('groupUniformB');
    const groupNormal = document.getElementById('groupNormal');
    const groupNormalSigma = document.getElementById('groupNormalSigma');
    const groupManual = document.getElementById('groupManual');

    const statN = document.getElementById('statN');
    const statMean = document.getElementById('statMean');
    const statVar = document.getElementById('statVar');
    const statStd = document.getElementById('statStd');

    const btnStream = document.getElementById('btnStream');
    const btnStep = document.getElementById('btnStep');
    const btnReset = document.getElementById('btnReset');

    function updateSourceUI(){
      const src = srcSelect.value;
      [groupUniform, groupUniformB, groupNormal, groupNormalSigma, groupManual]
        .forEach(el => el.classList.add('hidden'));

      [aInput,bInput,muInput,sigmaInput,manualInput].forEach(el => el.disabled = true);

      if (src === 'uniform') {
        groupUniform.classList.remove('hidden');
        groupUniformB.classList.remove('hidden');
        aInput.disabled = false; bInput.disabled = false;
      } else if (src === 'normal') {
        groupNormal.classList.remove('hidden');
        groupNormalSigma.classList.remove('hidden');
        muInput.disabled = false; sigmaInput.disabled = false;
      } else if (src === 'manual') {
        groupManual.classList.remove('hidden');
        manualInput.disabled = false;
      }
    }
    srcSelect.addEventListener('change', updateSourceUI);
    btnBigNum.addEventListener('click', () => {
        manualInput.value = "100000001, 100000002, 100000003";
    });

    const idxs = [];
    const runningMean = [];
    const theoryMean = [];
    const runningVar = [];
    const theoryVar = [];

    const commonOptions = {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { title:{display:true, text:'n'}, grid:{color:'rgba(0,0,0,0.06)'} },
        y: { grid:{color:'rgba(0,0,0,0.06)'} }
      },
      plugins: { legend: { display: true, position: 'top' } },
      animation: false
    };

    const meanChart = new Chart(document.getElementById('meanChart').getContext('2d'), {
      type: 'line',
      data: {
        labels: idxs,
        datasets: [
          {
            label: 'Running Mean',
            data: runningMean,
            borderColor: 'rgba(52,152,219,1)',
            backgroundColor: 'rgba(52,152,219,0.1)',
            borderWidth: 2, pointRadius: 0, tension: 0.15, fill: false
          },
          {
            label: 'Theoretical Mean',
            data: theoryMean,
            borderColor: '#2ecc71',
            borderWidth: 2,
            borderDash: [5, 5],
            pointRadius: 0
          }
        ]
      },
      options: commonOptions
    });

    const varChart = new Chart(document.getElementById('varChart').getContext('2d'), {
      type: 'line',
      data: {
        labels: idxs,
        datasets: [
          {
            label: 'Running Variance',
            data: runningVar,
            borderColor: 'rgba(231,76,60,1)',
            backgroundColor: 'rgba(231,76,60,0.1)',
            borderWidth: 2, pointRadius: 0, tension: 0.15, fill: false
          },
          {
            label: 'Theoretical Variance',
            data: theoryVar,
            borderColor: '#2ecc71',
            borderWidth: 2,
            borderDash: [5, 5],
            pointRadius: 0
          }
        ]
      },
      options: commonOptions
    });

    const wf = new Welford();

    function getTheoreticalValues() {
      const src = srcSelect.value;
      if (src === 'uniform') {
        const a = parseFloat(aInput.value);
        const b = parseFloat(bInput.value);
        return { mean: (a + b) / 2, var: Math.pow(b - a, 2) / 12 };
      }
      if (src === 'normal') {
        return { mean: parseFloat(muInput.value), var: parseFloat(sigmaInput.value) ** 2 };
      }
      return { mean: NaN, var: NaN };
    }

    function updateStatsPanel(){
      statN.textContent = wf.count();
      statMean.textContent = Number.isFinite(wf.mean) ? wf.mean.toFixed(6) : '—';
      const v = wf.sampleVariance();
      statVar.textContent = Number.isFinite(v) ? v.toFixed(6) : '—';
      const s = wf.std();
      statStd.textContent = Number.isFinite(s) ? s.toFixed(6) : '—';
    }

    function pushPoint(x, theories){
      wf.add(x);
      const n = wf.count();

      if (idxs.length === 0 || idxs[idxs.length-1] !== n) {
        idxs.push(n);
        runningMean.push(wf.mean);
        runningVar.push(wf.sampleVariance());

        theoryMean.push(theories.mean);
        theoryVar.push(theories.var);
      }

      meanChart.update('none');
      varChart.update('none');
      updateStatsPanel();
    }

    function streamBatch(){
      const src = srcSelect.value;
      const batch = Math.max(1, Math.floor(Number(nBatchInput.value)));
      const theories = getTheoreticalValues();

      if (src === 'uniform') {
        const a = Number(aInput.value), b = Number(bInput.value);
        for (let i=0;i<batch;i++) pushPoint(randUniform(a,b), theories);
      } else if (src === 'normal') {
        const mu = Number(muInput.value), sigma = Number(sigmaInput.value);
        for (let i=0;i<batch;i++) pushPoint(randNormal(mu,sigma), theories);
      } else {
        const nums = parseManual(manualInput.value);
        const take = Math.min(batch, nums.length);
        for (let i=0;i<take;i++) pushPoint(nums[i], theories);
      }
    }

    function stepOne(){
      const src = srcSelect.value;
      const theories = getTheoreticalValues();

      if (src === 'uniform') {
        pushPoint(randUniform(Number(aInput.value), Number(bInput.value)), theories);
      } else if (src === 'normal') {
        pushPoint(randNormal(Number(muInput.value), Number(sigmaInput.value)), theories);
      } else {
        const nums = parseManual(manualInput.value);
        if (nums.length){
           pushPoint(nums[0], theories);
           manualInput.value = nums.slice(1).join(', ');
        }
      }
    }

    function resetAll(){
      wf.reset();
      idxs.length = 0;
      runningMean.length = 0; theoryMean.length = 0;
      runningVar.length = 0; theoryVar.length = 0;
      meanChart.update();
      varChart.update();
      updateStatsPanel();
    }

    btnStream.addEventListener('click', streamBatch);
    btnStep.addEventListener('click', stepOne);
    btnReset.addEventListener('click', resetAll);

    updateSourceUI();
    updateStatsPanel();
  </script>
</body>
</html>