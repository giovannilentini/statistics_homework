<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework 4</title>
    <link rel="stylesheet" href="../include/css/style.css">
    <link rel="stylesheet" href="../include/css/content.css">
    <link rel="stylesheet" href="../include/css/code.css">
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <script>
        window.MathJax = {
            tex: { 
                inlineMath: [['\\(', '\\)']], 
                displayMath: [['\\[', '\\]']] 
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        .simulation-controls {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.4rem;
        }

        .control-group input {
            padding: 0.5rem;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 0.95rem;
            background: white;
            color: #2c3e50;
        }

        .button-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .sim-btn {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sim-btn-primary { background: #3498db; color: white; }
        .sim-btn-primary:hover { background: #2980b9; transform: translateY(-1px); }

        .sim-btn-success { background: #2ecc71; color: white; }
        .sim-btn-success:hover { background: #27ae60; transform: translateY(-1px); }

        .sim-btn-warning { background: #f39c12; color: white; }
        .sim-btn-warning:hover { background: #e67e22; transform: translateY(-1px); }

        .sim-btn-danger { background: #e74c3c; color: white; }
        .sim-btn-danger:hover { background: #c0392b; transform: translateY(-1px); }

        .status-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
            font-size: 0.95rem;
        }

        .charts-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .chart-wrapper {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .chart-wrapper h4 {
            color: #2c3e50;
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            font-weight: 600;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #3498db;
        }

        .chart-canvas-container {
            position: relative;
            height: 400px;
            width: 100%;
        }

        .chart-info {
            margin-top: 1rem;
            padding: 0.75rem;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 0.9rem;
            color: #555;
            border-left: 4px solid #3498db;
        }

        @media (max-width: 768px) {
            .button-group { flex-direction: column; }
            .sim-btn { width: 100%; }
            .chart-canvas-container { height: 300px; }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Statistics Course Blog</h1>
            <p class="subtitle">Law of Large Numbers Simulation</p>
            <p class="student-info">Giovanni Lentini - 1987799</p>
        </div>
    </header>

    <main class="container">
        <div class="back-navigation">
            <a href="../index.html" class="btn-back">← Back to Home</a>
        </div>

        <article class="homework-detail">
            <div class="homework-header">
                <h2>Homework 4: Law of Large Numbers Simulation</h2>
                <div class="meta-info">
                    <span class="date">Due: October 29, 2025</span>
                </div>
            </div>

            <section class="homework-content">
                <p class="intro-paragraph">
                    <strong>Does a coin have memory?</strong> If you flip a fair coin and get "Heads" 10 times in a row, intuition suggests "Tails" is due. However, the coin has no memory—the probability remains 50%. 
                </p>
                <p>
                    This interactive simulation demonstrates the <strong>Law of Large Numbers (LLN)</strong>. It visualizes how the accumulation of random events (Bernoulli trials) eventually overcomes randomness to reveal the underlying probability \(p\). By observing multiple trajectories simultaneously, we can see the "noise" of small samples dampen into the "signal" of the true expected value.
                </p>

                <h3>Interactive Simulation</h3>
                <p>Configure the parameters below. The red dashed lines in the chart represent the "Cone of Convergence" (95% confidence interval), showing where trajectories are statistically expected to fall.</p>

                <div class="simulation-controls">
                    <div class="status-info">
                        <strong>How to use:</strong> Press <strong>Simulate</strong> to generate data. Press <strong>Play</strong> to watch the convergence animate over time.
                    </div>

                    <div class="controls-grid">
                        <div class="control-group">
                            <label for="mInput">Number of trajectories (m)</label>
                            <input id="mInput" type="number" min="1" max="2000" value="100" />
                        </div>
                        <div class="control-group">
                            <label for="nInput">Trials per trajectory (n)</label>
                            <input id="nInput" type="number" min="10" max="5000" value="1000" />
                        </div>
                        <div class="control-group">
                            <label for="pInput">Probability of success (p)</label>
                            <input id="pInput" type="number" step="0.01" min="0" max="1" value="0.5" />
                        </div>
                        <div class="control-group">
                            <label for="binsInput">Histogram bins</label>
                            <input id="binsInput" type="number" min="5" max="100" value="50" />
                        </div>
                        <div class="control-group">
                            <label for="sampleInput">Show sample lines</label>
                            <input id="sampleInput" type="number" min="1" max="200" value="50" />
                        </div>
                    </div>

                    <div class="button-group">
                        <button class="sim-btn sim-btn-primary" id="simulateBtn">Simulate</button>
                        <button class="sim-btn sim-btn-success" id="playBtn">Play</button>
                        <button class="sim-btn sim-btn-warning" id="stepBtn">Step</button>
                        <button class="sim-btn sim-btn-danger" id="resetBtn">Reset</button>
                    </div>

                    <div class="chart-info">
                        <strong>Current trial:</strong> <span id="currentN">0</span> / <span id="totalN">0</span> | 
                        <strong>p =</strong> <span id="displayP">0.5</span>
                    </div>
                </div>

                <div class="charts-container">
                    <div class="chart-wrapper">
                        <h4>Relative Frequency Trajectories \(f(n)\)</h4>
                        <div class="chart-canvas-container">
                            <canvas id="lineChart"></canvas>
                        </div>
                        <div class="chart-info">
                            Gray lines: Individual trajectories. <br>
                            <span style="color:#3498db; font-weight:bold;">Blue line:</span> Theoretical probability \(p\). <br>
                            <span style="color:#e74c3c; font-weight:bold;">Red Dashed:</span> 95% Confidence Interval (\(p \pm 2\sigma\)). Notice how the lines stay inside the red funnel as \(n\) increases.
                        </div>
                    </div>

                    <div class="chart-wrapper">
                        <h4>Histogram of \(f(n)\) Distribution</h4>
                        <div class="chart-canvas-container">
                            <canvas id="histChart"></canvas>
                        </div>
                        <div class="chart-info">
                            Distribution of relative frequencies at the current trial \(n\). As \(n \to \infty\), the histogram narrows and spikes around \(p\).
                        </div>
                    </div>
                </div>

                <h3>Mathematical Foundation</h3>
                <p>The simulation is based on <strong>Bernoulli trials</strong>, where \(X_i = 1\) (success) with probability \(p\), and \(0\) otherwise. The relative frequency after \(n\) trials is the sample mean:</p>
                
                \[ \bar{X}_n = \frac{1}{n} \sum_{i=1}^{n} X_i \]

                <p>According to the <strong>Weak Law of Large Numbers (WLLN)</strong>, for any \(\epsilon > 0\):</p>
                
                \[ \lim_{n \to \infty} P\left( |\bar{X}_n - p| \ge \epsilon \right) = 0 \]

                <h4>Why does the chart narrow?</h4>
                <p>The visual "funnel" shape is explained by the variance of the sample mean. While the sum of successes has a variance that grows with \(n\), the <em>average</em> (relative frequency) has a variance that shrinks:</p>

                \[ \text{Var}(\bar{X}_n) = \frac{p(1-p)}{n} \]

                <p>Consequently, the standard deviation (the measure of "spread") decreases as the square root of \(n\):</p>
                
                \[ \sigma_{\bar{X}} = \sqrt{\frac{p(1-p)}{n}} \]
                
                <p>The red dashed lines in the chart plot \(p \pm 2\sigma_{\bar{X}}\). By Chebyshev's Inequality (or the Central Limit Theorem approximation), we expect roughly 95% of trajectories to remain within these bounds, visually proving that empirical results become more precise approximations of theoretical probability as sample size increases.</p>

                <h3>Key Observations</h3>
                <ul>
                    <li><strong>Cone of Convergence:</strong> Initially, trajectories fluctuate wildly. As \(n\) increases, they are confined within narrower bounds proportional to \(1/\sqrt{n}\).</li>
                    <li><strong>Law of Large Numbers vs. CLT:</strong> The LLN ensures the trajectories converge to the blue line (constant \(p\)). The Central Limit Theorem explains the shape of the histogram: it forms a Bell Curve (Normal Distribution) centered at \(p\) that becomes thinner and taller as \(n\) grows.</li>
                    <li><strong>Asymptotic Behavior:</strong> Individual trajectories may temporarily cross the red bounds, but the overall trend is strictly toward convergence.</li>
                </ul>
            </section>
        </article>
    </main>

    <script>

    function simulateBernoulli(m, n, p) {
        const trajectories = new Array(m);
        for (let i = 0; i < m; i++) {
            const traj = new Array(n);
            let cum = 0;
            for (let j = 0; j < n; j++) {
                const outcome = Math.random() < p ? 1 : 0;
                cum += outcome;
                traj[j] = cum / (j + 1);
            }
            trajectories[i] = traj;
        }
        return trajectories;
    }

    function computeHistogram(values, bins) {
        const min = 0, max = 1;
        const counts = new Array(bins).fill(0);
        const binWidth = (max - min) / bins;
        
        values.forEach(v => {
            let x = Math.max(min, Math.min(max, v));
            let idx = Math.floor((x - min) / binWidth);
            if (idx === bins) idx = bins - 1;
            counts[idx]++;
        });
        
        const labels = new Array(bins).fill(0).map((_, i) => (min + i * binWidth + binWidth / 2).toFixed(2));
        return { counts, labels };
    }

    let lineChart, histChart;
    
    function createCharts() {
        const ctxLine = document.getElementById('lineChart').getContext('2d');
        const ctxHist = document.getElementById('histChart').getContext('2d');

        lineChart = new Chart(ctxLine, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: { mode: 'nearest', axis: 'x', intersect: false },
                scales: {
                    x: { 
                        title: { display: true, text: 'Trial n', color: '#2c3e50' },
                        grid: { color: 'rgba(0,0,0,0.05)' }
                    },
                    y: { 
                        min: 0, max: 1, 
                        title: { display: true, text: 'Relative frequency f(n)', color: '#2c3e50' },
                        grid: { color: 'rgba(0,0,0,0.05)' }
                    }
                },
                plugins: { legend: { display: true, labels: { boxWidth: 10 } }, tooltip: { enabled: true } }
            }
        });

        histChart = new Chart(ctxHist, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{
                    label: 'Frequency',
                    data: [],
                    backgroundColor: 'rgba(52, 152, 219, 0.8)',
                    borderColor: 'rgba(52, 152, 219, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                scales: {
                    x: { 
                        title: { display: true, text: 'f(n) bins', color: '#2c3e50' },
                        grid: { display: false }
                    },
                    y: { 
                        title: { display: true, text: 'Count', color: '#2c3e50' },
                        grid: { color: 'rgba(0,0,0,0.05)' }
                    }
                },
                plugins: { legend: { display: false } }
            }
        });
    }

    let trajectories = [];
    let m = 100, n = 1000, p = 0.5, bins = 50, sample = 50;
    let currentN = 0;
    let playing = false;
    let playInterval = null;

    function updateDisplay() {
        document.getElementById('currentN').textContent = currentN;
        document.getElementById('totalN').textContent = n;
        document.getElementById('displayP').textContent = p.toFixed(2);
    }

    function drawLineChart() {
        const labels = new Array(currentN).fill(0).map((_, i) => i + 1);
        const datasets = [];

        const maxToShow = Math.min(sample, trajectories.length);
        const step = Math.floor(Math.max(1, trajectories.length / maxToShow));
        
        for (let i = 0, shown = 0; i < trajectories.length && shown < maxToShow; i += step, shown++) {
            datasets.push({
                label: `Traj ${i}`,
                data: trajectories[i].slice(0, currentN),
                borderWidth: 1,
                pointRadius: 0,
                fill: false,
                borderColor: 'rgba(189, 195, 199, 0.4)',
                order: 3
            });
        }

        const upperStd = [];
        const lowerStd = [];
        for(let k = 1; k <= currentN; k++) {
            const sd = Math.sqrt((p * (1 - p)) / k);
            upperStd.push(Math.min(1, p + 2 * sd));
            lowerStd.push(Math.max(0, p - 2 * sd));
        }

        datasets.push({
            label: 'Upper 95% Bound',
            data: upperStd,
            borderWidth: 1.5,
            pointRadius: 0,
            borderColor: 'rgba(231, 76, 60, 0.6)',
            borderDash: [5, 5],
            fill: false,
            order: 2
        });
        
        datasets.push({
            label: 'Lower 95% Bound',
            data: lowerStd,
            borderWidth: 1.5,
            pointRadius: 0,
            borderColor: 'rgba(231, 76, 60, 0.6)',
            borderDash: [5, 5],
            fill: false,
            order: 2
        });

        datasets.push({
            label: 'Theoretical p',
            data: new Array(currentN).fill(p),
            borderWidth: 2,
            pointRadius: 0,
            borderColor: '#3498db',
            borderDash: [],
            order: 1
        });

        lineChart.options.plugins.legend.labels.filter = function(item, chart) {
            return !item.text.includes('Traj');
        };

        lineChart.data.labels = labels;
        lineChart.data.datasets = datasets;
        lineChart.update();
    }

    function drawHistChart() {
        if (currentN === 0) return;
        
        const values = trajectories.map(traj => traj[currentN - 1]);
        const { counts, labels } = computeHistogram(values, bins);
        
        histChart.data.labels = labels;
        histChart.data.datasets[0].data = counts;
        histChart.update();
    }

    function simulateAndDraw() {
        m = Math.max(1, Math.floor(Number(document.getElementById('mInput').value)));
        n = Math.max(1, Math.floor(Number(document.getElementById('nInput').value)));
        p = Math.max(0, Math.min(1, Number(document.getElementById('pInput').value)));
        bins = Math.max(1, Math.floor(Number(document.getElementById('binsInput').value)));
        sample = Math.max(1, Math.floor(Number(document.getElementById('sampleInput').value)));

        trajectories = simulateBernoulli(m, n, p);
        currentN = 1;
        
        updateDisplay();
        drawLineChart();
        drawHistChart();
    }

    function stepSimulation() {
        if (trajectories.length === 0) {
            simulateAndDraw();
            return;
        }
        
        let jump = 1;
        if (n > 2000) jump = 20;
        else if (n > 1000) jump = 10;
        else if (n > 500) jump = 5;

        currentN = Math.min(n, currentN + jump);
        
        updateDisplay();
        drawLineChart();
        drawHistChart();
        
        if (currentN >= n) {
            stopPlay();
        }
    }

    function stopPlay() {
        if (playInterval) {
            clearInterval(playInterval);
            playInterval = null;
        }
        playing = false;
        document.getElementById('playBtn').textContent = 'Play';
        document.getElementById('playBtn').classList.remove('sim-btn-danger');
        document.getElementById('playBtn').classList.add('sim-btn-success');
    }

    function playSimulation() {
        if (!trajectories.length) simulateAndDraw();
        
        if (playing) {
            stopPlay();
            return;
        }

        playing = true;
        const btn = document.getElementById('playBtn');
        btn.textContent = 'Pause';
        btn.classList.remove('sim-btn-success');
        btn.classList.add('sim-btn-danger');

        playInterval = setInterval(() => {
            stepSimulation();
        }, 50);
    }

    function resetSimulation() {
        stopPlay();
        currentN = 0;
        trajectories = [];
        updateDisplay();
        lineChart.data.labels = [];
        lineChart.data.datasets = [];
        lineChart.update();
        histChart.data.labels = [];
        histChart.data.datasets[0].data = [];
        histChart.update();
    }

    window.addEventListener('load', () => {
        createCharts();
        updateDisplay();
        
        document.getElementById('simulateBtn').addEventListener('click', simulateAndDraw);
        document.getElementById('resetBtn').addEventListener('click', resetSimulation);
        document.getElementById('stepBtn').addEventListener('click', stepSimulation);
        document.getElementById('playBtn').addEventListener('click', playSimulation);

        simulateAndDraw();
    });
    </script>
</body>
</html>