<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Homework 10</title>

  <link rel="stylesheet" href="../include/css/style.css">
  <link rel="stylesheet" href="../include/css/content.css">
  <link rel="stylesheet" href="../include/css/code.css">

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    body { background-color: #fefefe; }
    header .subtitle { color: #555; }

    .simulation-controls {
      background: #f8f9fa;
      border-radius: 10px;
      padding: 2rem;
      margin: 2rem 0;
      box-shadow: 0 3px 10px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .status-info {
      background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
      color: #fff;
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      font-size: 0.95rem;
    }

    /* New Dynamic Analysis Box Style */
    .dynamic-analysis {
      background: #e8f6f3;
      border-left: 5px solid #27ae60;
      color: #2c3e50;
      padding: 1rem;
      border-radius: 4px;
      margin-top: 1rem;
      font-size: 0.95rem;
      display: none; /* Hidden until simulation runs */
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1rem 1.25rem;
    }

    .control-group { 
      display: flex; 
      flex-direction: column;
      gap: 0.4rem;
    }
    
    .control-group label { 
      font-size: 0.9rem; 
      font-weight: 600; 
      color: #2c3e50;
    }
    
    .control-group input {
      background: #fff; 
      border: 1px solid #bdc3c7; 
      border-radius: 6px;
      padding: 0.6rem 0.75rem; 
      color: #2c3e50; 
      font-size: 0.95rem;
      transition: all 0.15s ease-in-out;
    }
    
    .control-group input:focus {
      outline: none; 
      border-color: #3498db; 
      box-shadow: 0 0 0 3px rgba(155,89,182,0.15);
    }

    .button-group {
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      gap: 0.75rem;
      margin-top: 0.5rem;
    }
    
    .sim-btn {
      padding: 0.6rem 1.1rem; 
      border: none; 
      border-radius: 8px; 
      font-weight: 700;
      cursor: pointer; 
      transition: transform 0.1s ease, box-shadow 0.2s ease;
      color: #fff;
    }
    
    .sim-btn:hover { 
      transform: translateY(-1px); 
      box-shadow: 0 6px 12px rgba(0,0,0,0.12); 
    }
    
    .sim-btn-primary { background: #3498db; }
    .sim-btn-danger  { background: #c0392b; }

    .chart-info {
      font-size: 0.9rem; 
      color: #555; 
      background: #f8f9fa; 
      border-radius: 6px;
      padding: 0.75rem; 
      margin-top: 0.75rem;
    }

    .charts-container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1.5rem;
      margin: 2rem 0;
    }

    .chart-wrapper {
      background: #fff;
      border-radius: 8px;
      padding: 1.25rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    
    .chart-wrapper h4 {
      color: #2c3e50;
      margin: 0 0 0.75rem 0;
      font-size: 1.1rem;
      font-weight: 700;
      padding-bottom: 0.4rem;
      border-bottom: 2px solid #3498db;
    }

    .chart-canvas-container {
      position: relative;
      width: 100%;
      height: 420px;
    }
    
    @media (max-width: 768px) { 
      .chart-canvas-container { height: 340px; } 
    }

    .theory-box {
      background: linear-gradient(135deg, #ecf0f1 0%, #bdc3c7 100%);
      border-left: 4px solid #3498db;
      padding: 1.5rem;
      margin: 1.5rem 0;
      border-radius: 6px;
    }

    .theory-box h4 {
      color: #2c3e50;
      margin-top: 0;
      margin-bottom: 0.75rem;
    }

    /* Generic container for centered equations */
    .formula-container {
      background: #fff;
      padding: 0.5rem;
      border-radius: 4px;
      margin: 0.75rem 0;
      border: 1px solid #bdc3c7;
      text-align: center;
      overflow-x: auto;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0;
    }

    .stat-card {
      background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
      color: #fff;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
    }

    .stat-card .stat-label {
      font-size: 0.85rem;
      opacity: 0.9;
      margin-bottom: 0.25rem;
    }

    .stat-card .stat-value {
      font-size: 1.5rem;
      font-weight: 700;
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>Statistics Homework Blog</h1>
      <p class="subtitle">Poisson Process Simulation</p>
      <p class="student-info">Giovanni Lentini - 1987799</p>
    </div>
  </header>

  <main class="container">
    <div class="back-navigation">
      <a href="../index.html" class="btn-back">← Back to Home</a>
    </div>

    <article class="homework-detail">
      <div class="homework-header">
        <h2>Homework 10: Counting Process and Poisson Approximation</h2>
        <div class="meta-info">
          <span class="date">Due: November 17, 2025</span>
        </div>
      </div>

      <section class="homework-content">
        <p class="intro-paragraph">
          In this assignment, we simulate a counting process over a time interval \(T\) where events occur independently and uniformly in time at a constant average rate \(\lambda\). By dividing the interval into \(n\) small subintervals and generating events with probability \(p = \lambda/n\) in each (Bernoulli trials), we approximate a Poisson process.
        </p>

        <h3>Understanding the Counting Process</h3>
        <p>
          A <strong>counting process</strong> \(\{N(t), t \geq 0\}\) tracks the cumulative number of events up to time \(t\). 
        </p>

        <div class="theory-box">
          <h4>Theoretical Foundation</h4>
          <p><strong>Bernoulli to Poisson Convergence:</strong></p>
          <p>We model time as discrete steps. If \(n\) is large and \(p\) is small such that \(np = \lambda\) is constant, the Binomial distribution converges to the Poisson distribution:</p>
          <div class="formula-container">
            $$ \lim_{n \to \infty} \binom{n}{k} \left(\frac{\lambda}{n}\right)^k \left(1-\frac{\lambda}{n}\right)^{n-k} = \frac{\lambda^k e^{-\lambda}}{k!} $$
          </div>

          <p><strong>Poisson Properties:</strong></p>
          <ul>
            <li><strong>PMF:</strong> Probability of observing \(k\) events in time \(t\):</li>
          </ul>
          <div class="formula-container">
             $$ P(N(t) = k) = \frac{(\lambda t)^k e^{-\lambda t}}{k!} $$
          </div>
          <ul>
            <li><strong>Moments:</strong> The mean and variance are equal.</li>
          </ul>
          <div class="formula-container">
            $$ E[N(t)] = \lambda t \quad \text{and} \quad Var[N(t)] = \lambda t $$
          </div>
        </div>

        <h3>Interactive Simulation</h3>
        <p>
          Adjust the parameters below. Ensure that \(n\) is large enough so that the probability of an event in a single subinterval (\(\lambda T / n\)) is far less than 1.
        </p>

        <div class="simulation-controls">
          <div class="status-info">
            Interactive simulation — adjust \(\lambda\), \(T\), and \(n\), then click <strong>Simulate</strong>.
          </div>

          <div class="controls-grid">
            <div class="control-group">
              <label for="lambdaInput">Rate \(\lambda\) (events/unit time)</label>
              <input id="lambdaInput" type="number" step="0.5" min="0.5" max="50" value="10">
            </div>
            <div class="control-group">
              <label for="TInput">Time interval \(T\)</label>
              <input id="TInput" type="number" step="0.1" min="0.1" max="10" value="1">
            </div>
            <div class="control-group">
              <label for="nInput">Subintervals \(n\)</label>
              <input id="nInput" type="number" min="100" max="20000" step="100" value="5000">
            </div>
            <div class="control-group">
              <label for="mInput">Realizations \(m\)</label>
              <input id="mInput" type="number" min="1" max="1000" value="200">
            </div>
            <div class="control-group">
              <label for="showInput">Trajectories to display</label>
              <input id="showInput" type="number" min="1" max="50" value="20">
            </div>
            <div class="control-group">
              <label for="binsInput">Histogram bins</label>
              <input id="binsInput" type="number" min="5" max="50" value="20">
            </div>
          </div>

          <div class="button-group">
            <button class="sim-btn sim-btn-primary" id="simulateBtn">Simulate</button>
            <button class="sim-btn sim-btn-danger" id="resetBtn">Reset</button>
          </div>

          <div class="stats-grid" id="statsGrid">
            <div class="stat-card">
              <div class="stat-label">Theoretical \(E[N(T)]\)</div>
              <div class="stat-value" id="expectedValue">0.00</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Observed Mean</div>
              <div class="stat-value" id="observedMean">0.00</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Observed Variance</div>
              <div class="stat-value" id="observedVar">0.00</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Total Events</div>
              <div class="stat-value" id="totalEvents">0</div>
            </div>
          </div>
          
          <div id="dynamicAnalysis" class="dynamic-analysis"></div>
        </div>

        <div class="charts-container">
          <div class="chart-wrapper">
            <h4>Counting Process Trajectories \(N(t)\)</h4>
            <div class="chart-canvas-container">
              <canvas id="trajectoryChart"></canvas>
            </div>
            <div class="chart-info">
              The dashed red line represents the theoretical expectation \(E[N(t)] = \lambda t\). The grey lines are individual random realizations.
            </div>
          </div>

          <div class="chart-wrapper">
            <h4>Distribution of \(N(T)\) vs Theoretical Poisson</h4>
            <div class="chart-canvas-container">
              <canvas id="distributionChart"></canvas>
            </div>
            <div class="chart-info">
              Blue bars: Empirical distribution of final counts. Orange line: Theoretical Poisson PMF.
            </div>
          </div>

          <div class="chart-wrapper">
            <h4>Inter-event Times Distribution</h4>
            <div class="chart-canvas-container">
              <canvas id="interEventChart"></canvas>
            </div>
            <div class="chart-info">
              Waiting times between events. This should approximate an Exponential distribution with mean \(1/\lambda\).
            </div>
          </div>
        </div>

        <h3>Applications in Cybersecurity</h3>
        <p>
          Poisson processes are vital for modeling discrete events in continuous time:
        </p>
        <ul>
          <li><strong>DDoS Attacks:</strong> Modeling the arrival rate of malicious packets to a server. If the rate \(\lambda\) exceeds the server's processing capacity, the system queues overflow.</li>
          <li><strong>Brute Force:</strong> Analyzing the frequency of login attempts over time.</li>
          <li><strong>Failure Rates:</strong> Predicting hardware component failures in a large data center.</li>
        </ul>

      </section>
    </article>
  </main>

  <script>
    // Poisson probability mass function
    function poissonPMF(k, lambda) {
      if (lambda <= 0 || k < 0) return 0;
      const logProb = k * Math.log(lambda) - lambda - logFactorial(k);
      return Math.exp(logProb);
    }

    function logFactorial(n) {
      if (n <= 1) return 0;
      let sum = 0;
      for (let i = 2; i <= n; i++) sum += Math.log(i);
      return sum;
    }

    // Simulate one realization of counting process
    function simulateCountingProcess(lambda, T, n) {
      const dt = T / n;
      const p = lambda * dt; // Bernoulli probability
      const times = [0];
      const counts = [0];
      let count = 0;
      
      for (let i = 1; i <= n; i++) {
        if (Math.random() < p) count++;
        // Optimization: Only push data points periodically or when count changes
        // to save memory, but for homework visuals, we push steps.
        times.push(i * dt);
        counts.push(count);
      }
      
      return { times, counts };
    }

    function getInterEventTimes(times, counts) {
      const eventTimes = [];
      // Identify exact times when count incremented
      for (let i = 1; i < counts.length; i++) {
        if (counts[i] > counts[i - 1]) {
          eventTimes.push(times[i]);
        }
      }
      
      const interEventTimes = [];
      for (let i = 1; i < eventTimes.length; i++) {
        interEventTimes.push(eventTimes[i] - eventTimes[i - 1]);
      }
      return interEventTimes;
    }

    function computeHistogram(values, bins) {
      if (values.length === 0) return { counts: [], labels: [] };
      const vmin = Math.min(...values);
      const vmax = Math.max(...values);
      if (vmin === vmax) return { counts: [values.length], labels: [vmin.toFixed(1)] };
      
      const width = (vmax - vmin) / bins;
      const counts = new Array(bins).fill(0);
      
      values.forEach(v => {
        let idx = Math.floor((v - vmin) / width);
        if (idx >= bins) idx = bins - 1;
        counts[idx]++;
      });
      
      const labels = Array.from({ length: bins }, (_, i) =>
        (vmin + i * width + width / 2).toFixed(2)
      );
      return { counts, labels };
    }

    // Charts Global Variables
    let trajectoryChart, distributionChart, interEventChart;
    
    function createCharts() {
      // Common chart options
      const commonOptions = {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        plugins: { legend: { display: false } }
      };

      // 1. Trajectory Chart
      const ctxTraj = document.getElementById('trajectoryChart').getContext('2d');
      trajectoryChart = new Chart(ctxTraj, {
        type: 'line',
        data: { datasets: [] },
        options: {
          ...commonOptions,
          scales: {
            x: { type: 'linear', title: { display: true, text: 'Time t' } },
            y: { title: { display: true, text: 'Count N(t)' } }
          }
        }
      });

      // 2. Distribution Chart
      const ctxDist = document.getElementById('distributionChart').getContext('2d');
      distributionChart = new Chart(ctxDist, {
        type: 'bar',
        data: { labels: [], datasets: [] },
        options: {
          ...commonOptions,
          plugins: { legend: { display: true } },
          scales: {
            x: { title: { display: true, text: 'Count k' } },
            y: { title: { display: true, text: 'Probability' } }
          }
        }
      });

      // 3. Inter-Event Chart
      const ctxInter = document.getElementById('interEventChart').getContext('2d');
      interEventChart = new Chart(ctxInter, {
        type: 'bar',
        data: { labels: [], datasets: [] },
        options: {
          ...commonOptions,
          scales: {
            x: { title: { display: true, text: 'Inter-arrival Time' } },
            y: { title: { display: true, text: 'Frequency' } }
          }
        }
      });
    }

    // Variables
    let realizations = [];
    let lambda = 10, T = 1, n = 5000, m = 100, show = 20, bins = 20;

    function updateStats(finalCounts) {
      const expected = lambda * T;
      const mean = finalCounts.reduce((a, b) => a + b, 0) / finalCounts.length;
      const variance = finalCounts.reduce((a, b) => a + (b - mean) ** 2, 0) / finalCounts.length;
      const total = finalCounts.reduce((a, b) => a + b, 0);

      document.getElementById('expectedValue').textContent = expected.toFixed(2);
      document.getElementById('observedMean').textContent = mean.toFixed(2);
      document.getElementById('observedVar').textContent = variance.toFixed(2);
      document.getElementById('totalEvents').textContent = total;

      // Dynamic Analysis Logic
      const analysisDiv = document.getElementById('dynamicAnalysis');
      analysisDiv.style.display = 'block';
      
      const diffMean = Math.abs(mean - expected);
      const diffVar = Math.abs(variance - mean);
      
      let analysisHTML = `<strong>Analysis of this run:</strong><br>`;
      analysisHTML += `The empirical mean (<strong>${mean.toFixed(2)}</strong>) deviates from the theoretical expectation by ${diffMean.toFixed(3)}. `;
      
      if (diffVar < 1.0) {
        analysisHTML += `The variance (<strong>${variance.toFixed(2)}</strong>) is very close to the mean, which <em>strongly supports</em> the Poisson property ($Mean \\approx Variance$).`;
      } else {
        analysisHTML += `The variance (<strong>${variance.toFixed(2)}</strong>) deviates slightly from the mean (${diffVar.toFixed(2)}), which can happen with smaller sample sizes ($m$) or discrete approximations.`;
      }
      
      analysisDiv.innerHTML = analysisHTML;
      // Re-render math in the new HTML content
      if (window.MathJax) MathJax.typesetPromise([analysisDiv]);
    }

    function drawTrajectories() {
      const datasets = [];
      const step = Math.max(1, Math.floor(realizations.length / show));
      
      // Plot subset of realizations
      for (let i = 0; i < realizations.length && datasets.length < show; i += step) {
        const { times, counts } = realizations[i];
        // Downsample for performance if n is huge
        const stride = Math.ceil(times.length / 500); 
        const dataPoints = [];
        for(let j=0; j<times.length; j+=stride) {
            dataPoints.push({ x: times[j], y: counts[j] });
        }
        // Ensure last point is included
        dataPoints.push({ x: times[times.length-1], y: counts[counts.length-1] });

        datasets.push({
          data: dataPoints,
          borderColor: 'rgba(149, 165, 166, 0.4)',
          borderWidth: 1,
          pointRadius: 0,
          stepped: true,
          fill: false
        });
      }

      // Add Expected Trajectory LAST so it appears on top
      datasets.push({
        data: [{ x: 0, y: 0 }, { x: T, y: lambda * T }],
        borderColor: 'rgba(231, 76, 60, 0.9)',
        borderWidth: 3,
        borderDash: [8, 4],
        pointRadius: 0,
        fill: false,
        label: 'Theory'
      });

      trajectoryChart.data.datasets = datasets;
      trajectoryChart.update('none');
    }

    function drawDistribution() {
      const finalCounts = realizations.map(r => r.counts[r.counts.length - 1]);
      const minCount = Math.min(...finalCounts);
      const maxCount = Math.max(...finalCounts);
      
      const freq = {};
      finalCounts.forEach(c => freq[c] = (freq[c] || 0) + 1);
      
      const labels = [];
      const observed = [];
      const theoretical = [];
      
      // Expand range slightly for visual aesthetics
      for (let k = Math.max(0, minCount - 2); k <= maxCount + 2; k++) {
        labels.push(k.toString());
        observed.push((freq[k] || 0) / finalCounts.length);
        theoretical.push(poissonPMF(k, lambda * T));
      }

      distributionChart.data.labels = labels;
      distributionChart.data.datasets = [
        {
          label: 'Observed',
          data: observed,
          backgroundColor: 'rgba(52, 152, 219, 0.7)',
          order: 2
        },
        {
          label: 'Theoretical Poisson',
          data: theoretical,
          type: 'line',
          borderColor: 'rgba(230, 126, 34, 1)',
          borderWidth: 2,
          pointRadius: 3,
          tension: 0.3,
          order: 1
        }
      ];
      distributionChart.update('none');

      updateStats(finalCounts);
    }

    function drawInterEventTimes() {
      const allInterEventTimes = [];
      realizations.forEach(r => {
        allInterEventTimes.push(...getInterEventTimes(r.times, r.counts));
      });

      if (allInterEventTimes.length === 0) {
        interEventChart.data.labels = [];
        interEventChart.data.datasets = [];
        interEventChart.update();
        return;
      }

      const { counts, labels } = computeHistogram(allInterEventTimes, bins);
      const total = counts.reduce((a, b) => a + b, 0);
      const normalized = counts.map(c => c / total);

      interEventChart.data.labels = labels;
      interEventChart.data.datasets = [{
        label: 'Frequency',
        data: normalized,
        backgroundColor: 'rgba(155, 89, 182, 0.7)'
      }];
      interEventChart.update('none');
    }

    function simulate() {
      // 1. Get Values
      lambda = parseFloat(document.getElementById('lambdaInput').value);
      T = parseFloat(document.getElementById('TInput').value);
      n = parseInt(document.getElementById('nInput').value);
      m = parseInt(document.getElementById('mInput').value);
      show = parseInt(document.getElementById('showInput').value);
      bins = parseInt(document.getElementById('binsInput').value);

      // 2. Input Validation (New)
      if (lambda <= 0 || T <= 0 || n <= 0 || m <= 0) {
        alert("Please enter positive values for all parameters.");
        return;
      }
      
      // Check Probability Constraint for Poisson Approximation
      const p = lambda * (T / n);
      if (p >= 1) {
        alert(`Error: The probability per subinterval (λ * T / n) is ${p.toFixed(2)}. It must be < 1 (ideally < 0.01). Please increase n.`);
        return;
      }

      // 3. Run Simulation
      realizations = [];
      for (let i = 0; i < m; i++) {
        realizations.push(simulateCountingProcess(lambda, T, n));
      }

      // 4. Update UI
      drawTrajectories();
      drawDistribution();
      drawInterEventTimes();
    }

    function reset() {
      realizations = [];
      trajectoryChart.data.datasets = [];
      trajectoryChart.update();
      distributionChart.data.labels = [];
      distributionChart.data.datasets = [];
      distributionChart.update();
      interEventChart.data.labels = [];
      interEventChart.data.datasets = [];
      interEventChart.update();

      document.getElementById('expectedValue').textContent = '0.00';
      document.getElementById('observedMean').textContent = '0.00';
      document.getElementById('observedVar').textContent = '0.00';
      document.getElementById('totalEvents').textContent = '0';
      
      const analysisDiv = document.getElementById('dynamicAnalysis');
      analysisDiv.style.display = 'none';
      analysisDiv.innerHTML = '';
    }

    window.addEventListener('load', () => {
      createCharts();
      document.getElementById('simulateBtn').addEventListener('click', simulate);
      document.getElementById('resetBtn').addEventListener('click', reset);
      // Run once on load
      simulate();
    });
  </script>
</body>
</html>